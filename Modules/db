#!/usr/bin/env bash
# db â€” Centralized user DB + session logging helpers for SSH Plus Manager
#
# SPEC (authoritative storage):
#   - User DB:      $HOME/users.db
#   - Session log:  $HOME/sessions.log
#
# Users DB format (space-separated; exactly 8 fields):
#   username connection_limit expiration_date registration_date total_traffic last_connection_traffic latest_connection_date password
#
# Notes / assumptions:
# - "password" is stored as a deterministic hash for consistency (sha256), prefixed with "sha256:".
# - System password is set via `chpasswd` (non-interactive); we do not call `passwd`.
# - Updates are atomic (tmp + mv) and guarded by a lock (flock if available; mkdir-lock fallback).
# - Functions are pure bash and safe to source multiple times.

set -o nounset

sshplus_users_db_path() { printf "%s/users.db" "${HOME:-/root}"; }
sshplus_sessions_log_path() { printf "%s/sessions.log" "${HOME:-/root}"; }

_sshplus_db_lock_path() { printf "%s/users.db.lock" "${HOME:-/root}"; }
_sshplus_db_lock_dir() { printf "%s/users.db.lock.d" "${HOME:-/root}"; }

sshplus_now_date() { date +%F; }                 # YYYY-MM-DD
sshplus_now_iso()  { date -Iseconds 2>/dev/null || date +"%Y-%m-%dT%H:%M:%S%z"; }  # ISO-ish

sshplus_is_int() { [[ "${1:-}" =~ ^[0-9]+$ ]]; }
sshplus_is_date_or_never() {
  local d="${1:-}"
  [[ "$d" == "never" ]] && return 0
  [[ "$d" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || return 1
  date -d "$d" +%F >/dev/null 2>&1
}
sshplus_is_iso_or_never() {
  local s="${1:-}"
  [[ "$s" == "never" ]] && return 0
  # Accept common ISO forms; strict validation is hard without extra deps.
  [[ "$s" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T ]] || return 1
  return 0
}

# Deterministic password hash (for DB storage only)
sshplus_hash_password() {
  local pass="${1:-}"
  if command -v sha256sum >/dev/null 2>&1; then
    printf "sha256:%s" "$(printf "%s" "$pass" | sha256sum | awk '{print $1}')"
    return 0
  fi
  if command -v openssl >/dev/null 2>&1; then
    # openssl output: "(stdin)= <hash>"
    printf "sha256:%s" "$(printf "%s" "$pass" | openssl dgst -sha256 2>/dev/null | awk '{print $NF}')"
    return 0
  fi
  # Worst-case fallback: still return something stable
  printf "sha256:%s" "$pass"
}

sshplus_db_init() {
  local db log
  db="$(sshplus_users_db_path)"
  log="$(sshplus_sessions_log_path)"
  [[ -f "$db" ]] || { mkdir -p "$(dirname "$db")" 2>/dev/null || true; : > "$db"; chmod 600 "$db" 2>/dev/null || true; }
  [[ -f "$log" ]] || { mkdir -p "$(dirname "$log")" 2>/dev/null || true; : > "$log"; chmod 600 "$log" 2>/dev/null || true; }
}

# -------------------- locking --------------------
# Use flock if present; otherwise fallback to mkdir-lock directory.
_sshplus_lock_acquire() {
  sshplus_db_init
  if command -v flock >/dev/null 2>&1; then
    # shellcheck disable=SC2034
    exec 200> "$(_sshplus_db_lock_path)" || return 1
    flock -x 200
    return $?
  fi
  local d="$(_sshplus_db_lock_dir)" i
  for ((i=0; i<200; i++)); do
    mkdir "$d" 2>/dev/null && return 0
    sleep 0.02
  done
  return 1
}
_sshplus_lock_release() {
  if command -v flock >/dev/null 2>&1; then
    flock -u 200 2>/dev/null || true
    return 0
  fi
  rmdir "$(_sshplus_db_lock_dir)" 2>/dev/null || true
}

# Run a command while holding the DB lock.
sshplus_with_db_lock() {
  _sshplus_lock_acquire || return 1
  "$@"
  local rc=$?
  _sshplus_lock_release || true
  return $rc
}

# -------------------- DB primitives --------------------
sshplus_db_get_line() {
  local u="${1:-}" db
  db="$(sshplus_users_db_path)"
  [[ -z "$u" ]] && return 1
  grep -m1 -E "^${u}[[:space:]]" "$db" 2>/dev/null || true
}

sshplus_db_user_exists() {
  local u="${1:-}"
  [[ -n "$(sshplus_db_get_line "$u")" ]]
}

sshplus_db_put_user() {
  # Args: username connection_limit expiration_date registration_date total_traffic last_connection_traffic latest_connection_date password
  local u="${1:-}" lim="${2:-}" exp="${3:-}" reg="${4:-}" tot="${5:-}" last="${6:-}" latest="${7:-}" pass="${8:-}"
  local db tmp
  db="$(sshplus_users_db_path)"

  [[ -z "$u" ]] && return 1
  sshplus_is_int "$lim" || return 1
  sshplus_is_date_or_never "$exp" || return 1
  sshplus_is_date_or_never "$reg" || return 1
  sshplus_is_int "$tot" || return 1
  sshplus_is_int "$last" || return 1
  sshplus_is_iso_or_never "$latest" || return 1
  [[ -n "$pass" ]] || return 1

  tmp="$(mktemp "${db}.tmp.XXXXXX" 2>/dev/null || echo "${db}.tmp.$$")"
  # Keep all other users, then write this user's fresh record
  awk -v u="$u" '!(NF && $1==u)' "$db" 2>/dev/null > "$tmp" || : > "$tmp"
  printf "%s %s %s %s %s %s %s %s\n" "$u" "$lim" "$exp" "$reg" "$tot" "$last" "$latest" "$pass" >> "$tmp"
  mv -f "$tmp" "$db"
}

sshplus_db_remove_user() {
  local u="${1:-}" db tmp
  db="$(sshplus_users_db_path)"
  [[ -z "$u" ]] && return 1
  tmp="$(mktemp "${db}.tmp.XXXXXX" 2>/dev/null || echo "${db}.tmp.$$")"
  awk -v u="$u" '!(NF && $1==u)' "$db" 2>/dev/null > "$tmp" || : > "$tmp"
  mv -f "$tmp" "$db"
}

# Clear the entire DB (use under sshplus_with_db_lock)
sshplus_db_clear() {
  local db
  db="$(sshplus_users_db_path)"
  : > "$db"
}

# Ensure a record exists for a system user. If missing, create with safe defaults.
sshplus_db_ensure_user() {
  local u="${1:-}"
  [[ -z "$u" ]] && return 1
  sshplus_db_user_exists "$u" && return 0

  local exp="never"
  exp="$(chage -l "$u" 2>/dev/null | awk -F: '/Account expires/{gsub(/^[ \t]+/,"",$2); print $2; exit}')"
  [[ -z "$exp" || "$exp" == "never" ]] && exp="never" || exp="$(date -d "$exp" +%F 2>/dev/null || echo "never")"

  sshplus_db_put_user "$u" 1 "$exp" "$(sshplus_now_date)" 0 0 "never" "$(sshplus_hash_password "UNKNOWN")"
}

# Parse a DB line into fields (prints 8 fields, space-separated).
sshplus_db_parse_line() {
  # shellcheck disable=SC2034
  local line="${1:-}"
  awk '{print $1,$2,$3,$4,$5,$6,$7,$8}' <<<"$line"
}

# -------------------- DB field updates (call under sshplus_with_db_lock) --------------------
sshplus_db_set_limit() {
  local u="${1:-}" new_lim="${2:-}" line
  sshplus_is_int "$new_lim" || return 1
  sshplus_db_ensure_user "$u" || true
  line="$(sshplus_db_get_line "$u")"
  [[ -z "$line" ]] && return 1
  local _u lim exp reg tot last latest pass
  read -r _u lim exp reg tot last latest pass <<<"$(sshplus_db_parse_line "$line")"
  sshplus_db_put_user "$u" "$new_lim" "$exp" "$reg" "$tot" "$last" "$latest" "$pass"
}

sshplus_db_set_expiration() {
  local u="${1:-}" new_exp="${2:-}" line
  sshplus_is_date_or_never "$new_exp" || return 1
  sshplus_db_ensure_user "$u" || true
  line="$(sshplus_db_get_line "$u")"
  [[ -z "$line" ]] && return 1
  local _u lim exp reg tot last latest pass
  read -r _u lim exp reg tot last latest pass <<<"$(sshplus_db_parse_line "$line")"
  sshplus_db_put_user "$u" "$lim" "$new_exp" "$reg" "$tot" "$last" "$latest" "$pass"
}

sshplus_db_start_session() {
  # Set session start time and reset last_connection_traffic to 0
  local u="${1:-}" start_iso="${2:-}" line
  sshplus_is_iso_or_never "$start_iso" || return 1
  sshplus_db_ensure_user "$u" || true
  line="$(sshplus_db_get_line "$u")"
  [[ -z "$line" ]] && return 1
  local _u lim exp reg tot last latest pass
  read -r _u lim exp reg tot last latest pass <<<"$(sshplus_db_parse_line "$line")"
  sshplus_db_put_user "$u" "$lim" "$exp" "$reg" "$tot" 0 "$start_iso" "$pass"
}

sshplus_db_add_traffic() {
  # Increment total_traffic and set last_connection_traffic to session_bytes
  local u="${1:-}" delta_bytes="${2:-}" session_bytes="${3:-}" line
  sshplus_is_int "${delta_bytes:-0}" || delta_bytes=0
  sshplus_is_int "${session_bytes:-0}" || session_bytes=0
  sshplus_db_ensure_user "$u" || true
  line="$(sshplus_db_get_line "$u")"
  [[ -z "$line" ]] && return 1
  local _u lim exp reg tot last latest pass
  read -r _u lim exp reg tot last latest pass <<<"$(sshplus_db_parse_line "$line")"
  tot=$(( ${tot:-0} + ${delta_bytes:-0} ))
  sshplus_db_put_user "$u" "$lim" "$exp" "$reg" "$tot" "$session_bytes" "$latest" "$pass"
}

# -------------------- password sync --------------------
sshplus_set_system_password() {
  local u="${1:-}" pass="${2:-}"
  [[ -z "$u" || -z "$pass" ]] && return 1
  # Non-interactive; required to be root
  printf "%s:%s\n" "$u" "$pass" | chpasswd >/dev/null 2>&1
}

sshplus_db_set_password() {
  # Change system password then (only on success) update DB hash.
  local u="${1:-}" pass="${2:-}" line
  [[ -z "$u" ]] && return 1
  sshplus_db_ensure_user "$u" || true
  line="$(sshplus_db_get_line "$u")"
  [[ -z "$line" ]] && return 1

  sshplus_set_system_password "$u" "$pass" || return 1

  local _u lim exp reg tot last latest _pass
  read -r _u lim exp reg tot last latest _pass <<<"$(sshplus_db_parse_line "$line")"
  sshplus_db_put_user "$u" "$lim" "$exp" "$reg" "$tot" "$last" "$latest" "$(sshplus_hash_password "$pass")"
}

# -------------------- session logging --------------------
sshplus_log_session() {
  # start end delta user ip banner bytes
  local start="${1:-}" end="${2:-}" delta="${3:-}" u="${4:-}" ip="${5:-}" banner="${6:-}" bytes="${7:-}"
  local log
  log="$(sshplus_sessions_log_path)"
  sshplus_db_init
  # Apply privacy settings (optional)
  local log_ip_banner=1
  if [[ -f /etc/SSHPlus/privacy.conf ]]; then
    # shellcheck disable=SC1090
    . /etc/SSHPlus/privacy.conf 2>/dev/null || true
  fi
  if [[ "${LOG_IP_BANNER:-1}" -ne 1 ]]; then
    ip="hidden"
    banner="hidden"
  fi
  # Sanitize banner (spaces break the format)
  banner="${banner//[[:space:]]/_}"
  ip="${ip//[[:space:]]/}"
  sshplus_is_int "${bytes:-0}" || bytes=0
  [[ -z "$start" || -z "$end" || -z "$u" ]] && return 1
  # Append-only; never fail the caller hard.
  printf "%s %s %s %s %s %s %s\n" "$start" "$end" "$delta" "$u" "${ip:-unknown}" "${banner:-unknown}" "$bytes" >> "$log" 2>/dev/null || true
  return 0
}

