#!/bin/bash
# expirationmanager â€“ modern Expiration Manager screen (replaces changeexpiration/expiredusers UX)

# Load color helpers (install path vs dev path)
if [[ -f /etc/SSHPlus/colors ]]; then
  source /etc/SSHPlus/colors
elif [[ -f /bin/colors ]]; then
  source /bin/colors
elif [[ -f "$(dirname "$0")/colors" ]]; then
  source "$(dirname "$0")/colors"
fi

# Load centralized DB + logging helpers
if [[ -f /etc/SSHPlus/db ]]; then
  source /etc/SSHPlus/db
elif [[ -f /bin/db ]]; then
  source /bin/db
elif [[ -f "$(dirname "$0")/db" ]]; then
  source "$(dirname "$0")/db"
fi

# db enables nounset; interactive screens should be lenient
set +o nounset 2>/dev/null || true

DB_PATH="$(sshplus_users_db_path 2>/dev/null || printf "%s/users.db" "${HOME:-/root}")"

_trim() {
  local s="${1:-}"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf "%s" "$s"
}

_is_int() { [[ "${1:-}" =~ ^[0-9]+$ ]]; }

_date_to_epoch() {
  local ymd="${1:-}"
  [[ -z "$ymd" || "$ymd" == "never" ]] && { echo ""; return 0; }
  date -d "$ymd" +%s 2>/dev/null || echo ""
}

_fmt_ddmmyyyy() {
  local ymd="${1:-}"
  [[ -z "$ymd" || "$ymd" == "never" ]] && { printf "never"; return 0; }
  date -d "$ymd" '+%d/%m/%Y' 2>/dev/null || printf "%s" "$ymd"
}

_days_remaining() {
  local ymd="${1:-}" now_s exp_s
  [[ -z "$ymd" || "$ymd" == "never" ]] && { echo "999999"; return 0; }
  now_s=$(date +%s 2>/dev/null)
  exp_s="$(_date_to_epoch "$ymd")"
  [[ -z "$now_s" || -z "$exp_s" ]] && { echo "999999"; return 0; }
  echo $(( (exp_s - now_s) / 86400 ))
}

_is_locked() {
  local u="$1"
  if command -v passwd >/dev/null 2>&1; then
    # passwd -S: "user P ..." or "user L ..."
    passwd -S "$u" 2>/dev/null | awk '{print $2}' | grep -q '^L$'
    return $?
  fi
  return 1
}

_lock_user() {
  local u="$1"
  command -v usermod >/dev/null 2>&1 && usermod -L "$u" >/dev/null 2>&1 && return 0
  command -v passwd  >/dev/null 2>&1 && passwd -l "$u" >/dev/null 2>&1 && return 0
  return 1
}

_unlock_user() {
  local u="$1"
  command -v usermod >/dev/null 2>&1 && usermod -U "$u" >/dev/null 2>&1 && return 0
  command -v passwd  >/dev/null 2>&1 && passwd -u "$u" >/dev/null 2>&1 && return 0
  return 1
}

_set_system_expiry() {
  local u="$1" ymd="$2"
  [[ -z "$u" ]] && return 1
  [[ "$ymd" == "never" ]] && return 0
  command -v chage >/dev/null 2>&1 || return 1
  chage -E "$ymd" "$u" >/dev/null 2>&1 || return 1
  return 0
}

_status_for_days() {
  local ymd="$1" days="$2"
  if [[ "$ymd" != "never" ]] && [[ "$days" -le 0 ]]; then
    echo "expired"
  elif [[ "$ymd" != "never" ]] && [[ "$days" -le 7 ]]; then
    echo "expiring"
  else
    echo "valid"
  fi
}

_status_badge() {
  local s="$1" locked="${2:-0}"
  if [[ "$locked" -eq 1 ]]; then
    printf "%bðŸ”’ disabled%b" "$(c ui_warn)" "$(reset)"
    return 0
  fi
  case "$s" in
    expired)  printf "%bâ›” expired%b"   "$(c ui_danger)" "$(reset)" ;;
    expiring) printf "%bâš  expiring%b"  "$(c ui_warn)" "$(reset)" ;;
    *)        printf "%bâœ… valid%b"     "$(c ui_ok)" "$(reset)" ;;
  esac
}

_enforce_expired_lock() {
  # Ensure expired users cannot login: lock system account if expired
  local u="$1" exp="$2" days="$3"
  [[ -z "$u" || -z "$exp" || "$exp" == "never" ]] && return 0
  if [[ "$days" -le 0 ]]; then
    _set_system_expiry "$u" "$exp" >/dev/null 2>&1 || true
    _lock_user "$u" >/dev/null 2>&1 || true
  fi
}

_read_users_db() {
  # Outputs records as: username|limit|exp|exp_fmt|days|status|locked
  [[ -f "$DB_PATH" ]] || return 0
  while read -r u lim exp reg tot last latest pass; do
    [[ -z "${u:-}" ]] && continue
    [[ -z "${exp:-}" ]] && exp="never"
    days="$(_days_remaining "$exp")"
    status="$(_status_for_days "$exp" "$days")"
    locked=0
    _is_locked "$u" && locked=1
    _enforce_expired_lock "$u" "$exp" "$days"
    exp_fmt="$(_fmt_ddmmyyyy "$exp")"
    printf "%s|%s|%s|%s|%s|%s|%s\n" "$u" "${lim:-1}" "$exp" "$exp_fmt" "$days" "$status" "$locked"
  done < "$DB_PATH"
}

_apply_filter() {
  local filter="$1"
  case "$filter" in
    expired)  awk -F'|' '$6=="expired"' ;;
    expiring) awk -F'|' '($6=="expiring")' ;;
    *)        cat ;;
  esac
}

_apply_sort() {
  local sort="$1"
  case "$sort" in
    username) sort -t'|' -k1,1 ;;
    expiry)   sort -t'|' -k3,3 ;;
    *)        sort -t'|' -k5,5n ;; # remaining days
  esac
}

_counts() {
  # stdin records; outputs: total valid expiring expired
  awk -F'|' '
    {t++}
    $6=="valid"{v++}
    $6=="expiring"{e++}
    $6=="expired"{x++}
    END{printf "%d %d %d %d", t+0, v+0, e+0, x+0}
  '
}

_print_screen() {
  local filter="$1" sort="$2" sort_label="$3"
  local all tmp total v e x
  tmp="$(mktemp /tmp/sshplus-exp.XXXXXX 2>/dev/null || echo /tmp/sshplus-exp.$$)"
  _read_users_db | _apply_filter "$filter" | _apply_sort "$sort" >"$tmp"
  read -r total v e x <<<"$(_counts <"$tmp")"

  clear
  title_line "EXPIRATION MANAGER"
  printf "\nðŸ‘¤ %s users   âœ… %s valid   âš  %s expiringâ‰¤7d   â›” %s expired\n" "$total" "$v" "$e" "$x"
  printf "Filter: %s  Sort: %s\n\n" "$filter" "$sort_label"

  printf "%b%-10s %-12s %-10s %s%b\n" "$(c ui_frame)" "USER" "EXPIRES" "REMAINING" "STATUS" "$(reset)"
  hr

  if [[ "$total" -eq 0 ]]; then
    printf "%b(no users match this filter)%b\n" "$(c muted)" "$(reset)"
    hr
    rm -f "$tmp" 2>/dev/null || true
    return 0
  fi

  local i line u lim exp exp_fmt days status locked rem_disp st_disp
  i=0
  while IFS='|' read -r u lim exp exp_fmt days status locked; do
    ((i++)) || true
    idx=$(printf "%02d" "$i")
    rem_disp="${days}d"
    [[ "$exp" == "never" ]] && rem_disp="âˆž"
    st_disp="$(_status_badge "$status" "$locked")"
    printf "%b[%s]%b %-10s %-12s %-10s %s\n" \
      "$(c ui_menu_num)" "$idx" "$(reset)" \
      "$u" "$exp_fmt" "$rem_disp" "$st_disp"
  done <"$tmp"
  hr
  rm -f "$tmp" 2>/dev/null || true
}

_select_user_record() {
  # Args: idx filter sort; prints record line or empty
  local idx="$1" filter="$2" sort="$3"
  local tmp line
  tmp="$(mktemp /tmp/sshplus-exp.XXXXXX 2>/dev/null || echo /tmp/sshplus-exp.$$)"
  _read_users_db | _apply_filter "$filter" | _apply_sort "$sort" >"$tmp"
  line="$(awk -v n="$idx" 'NR==n{print; exit}' "$tmp")"
  rm -f "$tmp" 2>/dev/null || true
  printf "%s" "$line"
}

_confirm() {
  local msg="$1" ans
  printf "%b%s [y/N]:%b " "$(c ui_prompt)" "$msg" "$(reset)"
  read -r ans || ans=""
  [[ "$ans" =~ ^[Yy]$ ]]
}

_parse_ddmmyyyy_to_ymd() {
  local dmy="$1"
  if ! [[ "$dmy" =~ ^([0-9]{2})/([0-9]{2})/([0-9]{4})$ ]]; then
    echo ""
    return 1
  fi
  echo "${BASH_REMATCH[3]}-${BASH_REMATCH[2]}-${BASH_REMATCH[1]}"
}

_renew_user() {
  local u="$1" cur_exp="$2"
  printf "%bRenew: add days (7/30/90/custom):%b " "$(c ui_prompt)" "$(reset)"
  read -r choice || choice=""
  choice="$(_trim "$choice")"
  case "$choice" in
    7|30|90) add="$choice" ;;
    *) printf "%bCustom days:%b " "$(c ui_prompt)" "$(reset)"; read -r add || add=""; add="$(_trim "$add")" ;;
  esac
  _is_int "$add" || { msg_err "Invalid days."; return 1; }
  [[ "$add" -lt 1 ]] && { msg_err "Days must be >= 1."; return 1; }
  new_exp="$(date -d "+${add} days" +%F 2>/dev/null)" || { msg_err "Date calc failed."; return 1; }
  sshplus_with_db_lock sshplus_db_set_expiration "$u" "$new_exp" >/dev/null 2>&1 || true
  _set_system_expiry "$u" "$new_exp" >/dev/null 2>&1 || true
  _unlock_user "$u" >/dev/null 2>&1 || true
  msg_ok "Renewed: $u expires $(date -d "$new_exp" '+%d/%m/%Y' 2>/dev/null)"
  return 0
}

_set_expiration_date() {
  local u="$1"
  printf "%bSet expiration (DD/MM/YYYY):%b " "$(c ui_prompt)" "$(reset)"
  read -r dmy || dmy=""
  dmy="$(_trim "$dmy")"
  ymd="$(_parse_ddmmyyyy_to_ymd "$dmy" 2>/dev/null || true)"
  [[ -z "$ymd" ]] && { msg_err "Invalid date format."; return 1; }
  date -d "$ymd" +%F >/dev/null 2>&1 || { msg_err "Invalid date."; return 1; }
  sshplus_with_db_lock sshplus_db_set_expiration "$u" "$ymd" >/dev/null 2>&1 || true
  _set_system_expiry "$u" "$ymd" >/dev/null 2>&1 || true
  # Enforce lock if now expired, else unlock
  days="$(_days_remaining "$ymd")"
  if [[ "$days" -le 0 ]]; then
    _lock_user "$u" >/dev/null 2>&1 || true
  else
    _unlock_user "$u" >/dev/null 2>&1 || true
  fi
  msg_ok "Set expiration for $u to $dmy"
  return 0
}

_disable_login() {
  local u="$1"
  _lock_user "$u" >/dev/null 2>&1 && msg_ok "Login disabled for $u" || msg_warn "Could not lock $u"
}

_enable_login() {
  local u="$1" exp="$2"
  days="$(_days_remaining "$exp")"
  if [[ "$exp" != "never" ]] && [[ "$days" -le 0 ]]; then
    msg_warn "User is expired. Renew or set a future date first."
    return 1
  fi
  _unlock_user "$u" >/dev/null 2>&1 && msg_ok "Login enabled for $u" || msg_warn "Could not unlock $u"
}

_delete_user() {
  local u="$1"
  _confirm "Delete user '$u'?" || return 1
  pkill -f "$u" 2>/dev/null || true
  userdel --force "$u" 2>/dev/null || true
  sshplus_with_db_lock sshplus_db_remove_user "$u" >/dev/null 2>&1 || true
  msg_ok "Deleted user $u"
}

_delete_all_expired() {
  _confirm "Delete ALL expired users?" || return 1
  local tmp u lim exp exp_fmt days status locked
  tmp="$(mktemp /tmp/sshplus-expdel.XXXXXX 2>/dev/null || echo /tmp/sshplus-expdel.$$)"
  _read_users_db | awk -F'|' '$6=="expired"{print $0}' >"$tmp"
  while IFS='|' read -r u lim exp exp_fmt days status locked; do
    [[ -z "$u" ]] && continue
    pkill -f "$u" 2>/dev/null || true
    userdel --force "$u" 2>/dev/null || true
    sshplus_with_db_lock sshplus_db_remove_user "$u" >/dev/null 2>&1 || true
  done <"$tmp"
  rm -f "$tmp" 2>/dev/null || true
  msg_ok "Expired users removed."
}

_user_actions() {
  local rec="$1"
  IFS='|' read -r u lim exp exp_fmt days status locked <<<"$rec"
  clear
  title_line "USER ACTIONS"
  rem_disp="${days}d"; [[ "$exp" == "never" ]] && rem_disp="âˆž"
  st_txt="$(_status_badge "$status" "$locked")"
  printf "User: %s   Expires: %s (%s)   Limit: %s   Status: %s\n\n" "$u" "$exp_fmt" "$rem_disp" "$lim" "$st_txt"
  printf "Actions:\n"
  printf "%b[1]%b Renew (add days)\n" "$(c ui_menu_num)" "$(reset)"
  printf "%b[2]%b Set expiration date\n" "$(c ui_menu_num)" "$(reset)"
  printf "%b[3]%b Disable user login\n" "$(c ui_menu_num)" "$(reset)"
  printf "%b[4]%b Enable user login\n" "$(c ui_menu_num)" "$(reset)"
  printf "%b[5]%b Delete user\n" "$(c ui_menu_num)" "$(reset)"
  printf "%b[0]%b Back\n" "$(c ui_menu_num)" "$(reset)"
  printf "\n%b>%b " "$(c ui_prompt)" "$(reset)"
  read -r a || a=""
  case "$a" in
    1) _renew_user "$u" "$exp" ;;
    2) _set_expiration_date "$u" ;;
    3) _disable_login "$u" ;;
    4) _enable_login "$u" "$exp" ;;
    5) _delete_user "$u" ;;
    0) return 0 ;;
    *) msg_err "Invalid option." ;;
  esac
  printf "\n%bPress Enterâ€¦%b" "$(c ui_prompt)" "$(reset)"; read -r _ || true
  return 0
}

filter="all"
sort="remaining"
sort_state="remainingâ†‘"

while true; do
  _print_screen "$filter" "$sort" "$sort_state"
  printf "Select user [1-N] or command:\n"
  printf "  %b[e]%b expired only   %b[x]%b expiringâ‰¤7d   %b[a]%b all\n" "$(c ui_menu_num)" "$(reset)" "$(c ui_menu_num)" "$(reset)" "$(c ui_menu_num)" "$(reset)"
  printf "  %b[s]%b sort           %b[D]%b delete expired  %b[q]%b back\n" "$(c ui_menu_num)" "$(reset)" "$(c ui_menu_num)" "$(reset)" "$(c ui_menu_num)" "$(reset)"
  printf "%b>%b " "$(c ui_prompt)" "$(reset)"
  read -r inp || inp=""
  inp="$(_trim "$inp")"
  [[ -z "$inp" ]] && continue
  case "$inp" in
    q|Q|0) exit 0 ;;
    a|A) filter="all" ;;
    e|E) filter="expired" ;;
    x|X) filter="expiring" ;;
    s|S)
      if [[ "$sort" == "remaining" ]]; then
        sort="username"; sort_state="usernameâ†‘"
      elif [[ "$sort" == "username" ]]; then
        sort="expiry"; sort_state="expiryâ†‘"
      else
        sort="remaining"; sort_state="remainingâ†‘"
      fi
      ;;
    D)
      _delete_all_expired
      printf "\n%bPress Enterâ€¦%b" "$(c ui_prompt)" "$(reset)"; read -r _ || true
      ;;
    *)
      if _is_int "$inp"; then
        rec="$(_select_user_record "$inp" "$filter" "$sort")"
        if [[ -z "$rec" ]]; then
          msg_err "Invalid selection."
          sleep 1
        else
          _user_actions "$rec"
        fi
      else
        msg_err "Unknown command."
        sleep 1
      fi
      ;;
  esac
done

