#!/bin/bash

# Color Utility Functions for SSH Plus Manager
# This file provides easy-to-use color functions instead of hardcoded ANSI codes
#
# USAGE EXAMPLES:
#   source /etc/SSHPlus/colors
#   
#   # Simple colored text
#   color_echo "Hello World" "green"
#   color_echo "Error message" "red"
#   
#   # Menu options with colored brackets
#   menu_option "01" "BLUE" "red" "yellow"
#   
#   # Show the color selection menu
#   show_color_menu
#   
#   # Quick message functions
#   error_msg "Something went wrong!"
#   success_msg "Operation completed!"
#   warning_msg "Be careful!"
#   info_msg "Here's some information"

# Color code definitions
# These are the ANSI escape codes for different colors
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
MAGENTA='\033[1;35m'
CYAN='\033[1;36m'
WHITE='\033[1;37m'
BLACK='\033[1;30m'
RESET='\033[0m'

# Color names mapping for easy use
declare -A COLOR_MAP=(
    ['red']='\033[1;31m'
    ['green']='\033[1;32m'
    ['yellow']='\033[1;33m'
    ['blue']='\033[1;34m'
    ['magenta']='\033[1;35m'
    ['cyan']='\033[1;36m'
    ['white']='\033[1;37m'
    ['black']='\033[1;30m'
    ['rose']='\033[1;35m'      # Rose uses magenta
    ['orange']='\033[1;33m'     # Orange uses yellow
    ['purple']='\033[1;35m'     # Purple uses magenta
)

# Function: Print colored text
# Usage: color_echo "text" "color_name"
# Example: color_echo "Hello World" "green"
# This function handles fallback internally - no need to check if it exists
color_echo() {
    local text="$1"
    local color_name="${2:-white}"  # Default to white if no color specified
    
    # Convert color name to lowercase
    color_name=$(echo "$color_name" | tr '[:upper:]' '[:lower:]')
    
    # Check if COLOR_MAP is available (colors file was sourced)
    if [[ -n "${COLOR_MAP[$color_name]}" ]]; then
        # Use the color map if available
        local color_code="${COLOR_MAP[$color_name]}"
        local reset_code="${RESET:-\033[0m}"
        echo -e "${color_code}${text}${reset_code}"
    else
        # Fallback to hardcoded color codes if colors file wasn't loaded
        case "$color_name" in
            red)     echo -e "\033[1;31m${text}\033[0m" ;;
            green)   echo -e "\033[1;32m${text}\033[0m" ;;
            yellow)  echo -e "\033[1;33m${text}\033[0m" ;;
            blue)    echo -e "\033[1;34m${text}\033[0m" ;;
            magenta|rose|purple) echo -e "\033[1;35m${text}\033[0m" ;;
            cyan)    echo -e "\033[1;36m${text}\033[0m" ;;
            white)   echo -e "\033[1;37m${text}\033[0m" ;;
            black)   echo -e "\033[1;30m${text}\033[0m" ;;
            orange)  echo -e "\033[1;33m${text}\033[0m" ;;
            *)       echo -e "\033[1;37m${text}\033[0m" ;;  # Default to white
        esac
    fi
}

# Function: Print colored text without newline
# Usage: color_echo_n "text" "color_name"
# This function handles fallback internally - no need to check if it exists
color_echo_n() {
    local text="$1"
    local color_name="${2:-white}"
    
    color_name=$(echo "$color_name" | tr '[:upper:]' '[:lower:]')
    
    # Check if COLOR_MAP is available (colors file was sourced)
    if [[ -n "${COLOR_MAP[$color_name]}" ]]; then
        # Use the color map if available
        local color_code="${COLOR_MAP[$color_name]}"
        local reset_code="${RESET:-\033[0m}"
        echo -ne "${color_code}${text}${reset_code}"
    else
        # Fallback to hardcoded color codes if colors file wasn't loaded
        case "$color_name" in
            red)     echo -ne "\033[1;31m${text}\033[0m" ;;
            green)   echo -ne "\033[1;32m${text}\033[0m" ;;
            yellow)  echo -ne "\033[1;33m${text}\033[0m" ;;
            blue)    echo -ne "\033[1;34m${text}\033[0m" ;;
            magenta|rose|purple) echo -ne "\033[1;35m${text}\033[0m" ;;
            cyan)    echo -ne "\033[1;36m${text}\033[0m" ;;
            white)   echo -ne "\033[1;37m${text}\033[0m" ;;
            black)   echo -ne "\033[1;30m${text}\033[0m" ;;
            orange)  echo -ne "\033[1;33m${text}\033[0m" ;;
            *)       echo -ne "\033[1;37m${text}\033[0m" ;;  # Default to white
        esac
    fi
}

# Function: Print menu option with colored brackets and number
# Usage: menu_option "number" "text" "bracket_color" "text_color"
# Example: menu_option "01" "BLUE" "red" "yellow"
# This function handles fallback internally - no need to check if it exists
menu_option() {
    local number="$1"
    local text="$2"
    local bracket_color="${3:-red}"      # Default bracket color is red
    local text_color="${4:-yellow}"      # Default text color is yellow
    
    bracket_color=$(echo "$bracket_color" | tr '[:upper:]' '[:lower:]')
    text_color=$(echo "$text_color" | tr '[:upper:]' '[:lower:]')
    
    # Check if COLOR_MAP is available (colors file was sourced)
    if [[ -n "${COLOR_MAP[$bracket_color]}" ]]; then
        # Use the color map if available
        local bracket_code="${COLOR_MAP[$bracket_color]}"
        local text_code="${COLOR_MAP[$text_color]}"
        local number_code="${COLOR_MAP['cyan']}"
        local reset_code="${RESET:-\033[0m}"
        echo -e "${bracket_code}[${number_code}${number}${bracket_code}]${text_code} ${text}${reset_code}"
    else
        # Fallback to hardcoded color codes if colors file wasn't loaded
        echo -e "\033[1;31m[\033[1;36m${number}\033[1;31m] \033[1;33m${text}\033[0m"
    fi
}

# Function: Print error message in red
# Usage: error_msg "Error message"
# This function handles fallback internally - no need to check if it exists
error_msg() {
    color_echo "$1" "red"
}

# Function: Print success message in green
# Usage: success_msg "Success message"
# This function handles fallback internally - no need to check if it exists
success_msg() {
    color_echo "$1" "green"
}

# Function: Print warning message in yellow
# Usage: warning_msg "Warning message"
# This function handles fallback internally - no need to check if it exists
warning_msg() {
    color_echo "$1" "yellow"
}

# Function: Print info message in cyan
# Usage: info_msg "Info message"
# This function handles fallback internally - no need to check if it exists
info_msg() {
    color_echo "$1" "cyan"
}

# Function: Get color code string (for use in printf/string building)
# Usage: color_code "color_name"
# Returns: The ANSI color code string without reset
# Example: code=$(color_code "red")
get_color_code() {
    local color_name="$1"
    color_name=$(echo "$color_name" | tr '[:upper:]' '[:lower:]')
    
    # Check if COLOR_MAP is available
    if [[ -n "${COLOR_MAP[$color_name]}" ]]; then
        echo -n "${COLOR_MAP[$color_name]}"
    else
        # Fallback to hardcoded codes
        case "$color_name" in
            red)     echo -n "\033[1;31m" ;;
            green)   echo -n "\033[1;32m" ;;
            yellow)  echo -n "\033[1;33m" ;;
            blue)    echo -n "\033[1;34m" ;;
            magenta|rose|purple) echo -n "\033[1;35m" ;;
            cyan)    echo -n "\033[1;36m" ;;
            white)   echo -n "\033[1;37m" ;;
            black)   echo -n "\033[1;30m" ;;
            orange)  echo -n "\033[1;33m" ;;
            *)       echo -n "\033[1;37m" ;;  # Default to white
        esac
    fi
}

# Function: Get reset code string
# Usage: get_reset_code
# Returns: The ANSI reset code string
get_reset_code() {
    if [[ -n "$RESET" ]]; then
        echo -n "$RESET"
    else
        echo -n "\033[0m"
    fi
}

# Function: Print color selection menu (the annoying one we're replacing)
# Usage: show_color_menu
# This function handles fallback internally - no need to check if it exists
show_color_menu() {
    echo ""
    menu_option "01" "BLUE" "red" "yellow"
    menu_option "02" "GREEN" "red" "yellow"
    menu_option "03" "RED" "red" "yellow"
    menu_option "04" "YELLOW" "red" "yellow"
    menu_option "05" "ROSE" "red" "yellow"
    menu_option "06" "CYAN" "red" "yellow"
    menu_option "07" "ORANGE" "red" "yellow"
    menu_option "08" "PURPLE" "red" "yellow"
    menu_option "09" "BLACK" "red" "yellow"
    menu_option "10" "WITHOUT COLOR" "red" "yellow"
    echo ""
}

# Function: Get progress bar color codes (for fun_bar functions)
# Returns color codes for progress bar display
get_progress_colors() {
    local yellow_code=$(get_color_code "yellow")
    local red_code=$(get_color_code "red")
    local white_code=$(get_color_code "white")
    local green_code=$(get_color_code "green")
    local reset_code=$(get_reset_code)
    echo "${yellow_code}|${red_code}|${white_code}|${green_code}|${reset_code}"
}

# Function: Print header with blue background (replaces \E[44;1;37m format)
# Usage: print_header "Header Text"
print_header() {
    local text="$1"
    # Use tput for background color
    tput setab 4
    tput bold
    echo -e "\E[44;1;37m${text}\E[0m"
    tput sgr0
}

# Function: Print header with red background (replaces \E[41;1;37m format)
# Usage: print_header_red "Header Text"
print_header_red() {
    local text="$1"
    # Use tput for red background
    tput setab 1
    tput bold
    echo -e "\E[41;1;37m${text}\E[0m"
    tput sgr0
}
